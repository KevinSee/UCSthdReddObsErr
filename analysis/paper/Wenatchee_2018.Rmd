---
title: "Estimates of Wenatchee Steelhead Redds and Spawners in 2018"
author: "Kevin See"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    toc: yes
    includes:
      in_header: /Users/kevin/Dropbox/ISEMP/Paperwork/Biomark/Templates/header_ABS.tex
  word_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    reference_docx: /Users/kevin/Dropbox/ISEMP/Paperwork/Biomark/Templates/ReportTemplate.docx
  html_document:
    fig_caption: yes
    fig_height: 8
    fig_width: 8
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: yes
      smooth_scroll: yes
csl: /Users/kevin/Dropbox/Bibliography/StyleFiles/ecology.csl
subtitle: Upper Wenatchee
bibliography:
- /Users/kevin/Dropbox/Bibliography/Research.bib
- /Users/kevin/Dropbox/Bibliography/SoftwareCitations.bib
---

```{r functions, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
# setwd('Steelhead_2018')
library(pander)
library(captioner)
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
tab_nums = captioner(prefix = 'Table')
fig_nums = captioner()
panderOptions('big.mark', ',') # to use , in large numbers in tables
panderOptions('table.split.table', Inf) # so as to not break table onto new lines
panderOptions('missing', '--') # what to replace NAs with in tables

library(msm)
library(tidyverse)
library(magrittr)
library(lubridate)
library(readxl)
library(forcats)
library(english)
library(MuMIn)
library(gridExtra)
library(PITcleanr)

theme_set(theme_bw())

# function to calculate estimate of total redd counts and the standard error around that, based on Millar 2011 manuscript
GAUCfnc = function(myDat, SL=1, SL.se=0, v=1, v.se=0, fam='quasipoisson')
# myDat is a data frame containing columns named Visible.Redds and Day (Julian days)
# SL is mean stream life
# SL.se is the standard deviation (standard error?) for stream life
# v is overall observer efficiency
# v.se is standard deviation of overall observer efficiency
# fam is either quasipoisson or negative.binomial
{
  names(myDat)[grep('Redds', names(myDat))] = 'Redds'
  g.pois = glm(Redds ~ Day + I(Day^2), data=myDat, family=quasipoisson)
  if(fam=='negative.binomial') g = glm(Redds ~ Day + I(Day^2), data=myDat, family=negative.binomial(round(summary(g.pois)$dispersion)))
	if(fam=='quasipoisson')	g = g.pois
	x = coef(g)
	
	# F is redd days
	Fg = sqrt(-pi/x[3])*exp(x[1]-x[2]^2/(4*x[3]))
	# adjust redd days for operational redd life & net error
	E = Fg / (SL * v)	
	#Obtain std error of estimated redd-days, using delta method 
	# check that vcov is correct dim
	if(sum(dim(vcov(g))==c(3,3))==2)
	{
		F.se=deltamethod(~sqrt(-pi/x3)*exp(x1-x2^2/(4*x3)),mean=x,cov=vcov(g)) 
		
		#Include uncertainty in redd-days, stream-life and observer efficiency 
		E.se=deltamethod(~x1/(x2*x3),mean=c(Fg,SL,v),cov=diag(c(F.se,SL.se, v.se))^2) 
	}
	else E.se = NA
	
	tau2 = -1/(2*x[3])
	ms = x[2] * tau2
	a = exp(x[1] + ms^2/(2*tau2))
	params=c(tau2, ms, a)
	names(params) = c('tau2', 'ms', 'a')
	return(list(E=E, E.se=E.se, Fg = Fg, F.se = F.se, beta=x, Ncurve=params, model=g))
}

```

```{r model_selection}
# pull in data from published steelhead manuscript
load('/Users/kevin/Dropbox/Personal/ResearchPapers/2017_SthdReddObsError/Data/ModelSelection_20171020.rda')
fm_family = 'gaussian'
mod_data = mod_sel_list$Methow_neterr[[2]]
mod_df = mod_data

# model average
mod.avg = model.avg(mod_sel_list$Methow_neterr[[3]],
                    subset = delta <= 2,
                    fit = T)

# fullCoef = glm(paste('NetError_rate ~', paste(names(coef(mod.avg))[-1], collapse = ' + ')),
#               data = mod_df,
#               family = 'gaussian') %>%
#   coef()
# mod.avg$coefficients %>%
#   as.data.frame() %>%
#   mutate(type = row.names(.)) %>%
#   gather(param, coef, -type) %>%
#   bind_rows(data.frame(coef = fullCoef) %>%
#               mutate(param = row.names(.),
#                      type = 'oneMod')) %>%
#   spread(param, coef) %>%
#   mutate(type = factor(type,
#                        levels = c('full', 'subset', 'oneMod'))) %>%
#   arrange(type)

# # fit new full model, using only those covariates in any model with delta AICc < 2
# mod.avg = glm(paste('NetError_rate ~', paste(names(coef(mod.avg))[-1], collapse = ' + ')),
#               data = mod_df,
#               family = 'gaussian')

twoObs_df = redd_data %>%
  filter(Study_Watershed == "Methow") %>%
  select(one_of(names(mod_sel_list$Methow_neterr[[2]])))
  
covar_center = twoObs_df %>%
  select(one_of(names(coef(mod.avg)))) %>%
  gather(metric, value) %>%
  group_by(metric) %>%
  summarise_at(vars(value),
               funs(mean, sd)) %>%
  ungroup()

rm(fm_family, mod_data, metric_df, mod_sel_list, redd_data, smat)

```


```{r current_data}
# read in data from 2018 steelhead redd surveys
sthd_redd_org = read_excel('Data/2018_SteelheadData.xlsx',
                          sheet = 1) %>%
  rename(Visible.Redds = `Visible Redds`) %>%
  filter(!is.na(Reach)) %>%
  rename(ExpSpTotal = EXP_Total) %>%
  left_join(read_excel('Data/2018_SteelheadData.xlsx',
                       sheet = 'ReachArea')) %>%
  mutate_at(vars(River, Reach, Index, Survey.Type),
            funs(as.factor)) %>%
  mutate_at(vars(Reach.Area, MeanThalwegCV),
            funs(as.numeric)) %>%
  mutate_at(vars(ExpSpTotal),
            funs(log(. + 1))) %>%
  mutate(Survey.Date = ymd(Survey.Date),
         Day = yday(Survey.Date),
         NaiveDensity_km = Visible.Redds / (Length / 1000),
         MeanWidth_m = Reach.Area / Length) %>%
  mutate(Reach = fct_relevel(Reach, 'W10', after = Inf)) %>%
  mutate_at(vars(MeanThalwegCV),
            funs(. * 100))

# fix one thalweg data point
sthd_redd_org %<>%
  mutate_at(vars(MeanThalwegCV),
            funs(if_else(Reach == 'W10' & Index == 'Y',
                         0.580,
                         .)))

sthd_redd_df = sthd_redd_org %>%
  select(River:New.Redds,
         one_of(names(coef(mod.avg))[-1])) %>%
  gather(metric, value, one_of(names(coef(mod.avg))[-1])) %>%
  left_join(covar_center) %>%
  # mutate(value = (value - mean) / sd) %>%
  mutate(value = (value - mean)) %>%
  select(-mean, -sd) %>%
  spread(metric, value) %>%
  group_by(River, Reach, Survey.Type) %>%
  mutate(survey = 1:n()) %>%
  ungroup() %>%
  bind_cols(predict(mod.avg, 
                    newdata = ., 
                    backtransform = T,
                    type = 'link', 
                    se.fit = T) %>%
              as.data.frame() %>%
              tbl_df() %>%
              rename(Net.Error = fit,
                     Net.Error.SE = se.fit)) 
```

```{r covariate_plots}
ne.covars.p = twoObs_df %>%
  select(Watershed = Study_Watershed,
         River = Stream,
         Reach, 
         NetError_rate,
         one_of(names(coef(mod.avg))[-1])) %>%
  mutate(Source = 'Model Data') %>%
  bind_rows(sthd_redd_org %>%
              # filter(Index == 'Y') %>%
              select(River:Reach,
                     Index,
                     Survey.Date,
                     one_of(names(coef(mod.avg))[-1])) %>%
              mutate(Watershed = 'Wenatchee',
                     Source = 'New Data') %>%
              left_join(sthd_redd_df %>%
                          select(River, 
                                 Reach, 
                                 Index,
                                 Survey.Date,
                                 NetError_rate = Net.Error))) %>%
  select(Source, Watershed, River, Reach, 
         one_of(names(coef(mod.avg))[-1]),
         NetError_rate) %>%
  mutate(ExpSpTotal = exp(ExpSpTotal) - 1) %>%
  gather(variable, value, one_of(names(coef(mod.avg))[-1]), NetError_rate) %>%
  mutate(variable = recode(variable, 
                           'NetError_rate' = 'Net Error',
                           'MeanDischarge' = 'Mean Discharge',
                           'MeanThalwegCV' = 'Mean Thalweg CV',
                           'MeanWidth_m' = 'Mean Width (m)',
                           'NaiveDensity_km' = 'Obs Redd Density',
                           'ExpSpTotal' = 'Surveyor Exp.')) %>%
  mutate(variable = factor(variable,
                           levels = c('Mean Thalweg CV',
                                      'Obs Redd Density',
                                      'Surveyor Exp.',
                                      'Mean Discharge',
                                      'Mean Width (m)',
                                      'Net Error'))) %>%
  ggplot(aes(x = Source, 
             y = value)) +
  geom_boxplot(aes(fill = Watershed)) +
  scale_fill_brewer(palette = 'Set1') +
  facet_wrap(~ variable, 
             scales = 'free') +
  theme(legend.position = 'bottom') + 
  labs(title = 'Net Error Covariates')

ne.covars.p2 = mod_df %>%
  select(Watershed = Study_Watershed,
         River = Stream,
         Reach, 
         NetError_rate,
         one_of(names(coef(mod.avg))[-1])) %>%
  mutate(Source = 'Model Data') %>%
  bind_rows(sthd_redd_df %>%
              # filter(Index == 'Y') %>%
              select(River:Reach,
                     Index,
                     Survey.Date,
                     one_of(names(coef(mod.avg))[-1]),
                     NetError_rate = Net.Error) %>%
              mutate(Watershed = 'Wenatchee',
                     Source = 'New Data')) %>%
  select(Source, Watershed, River, Reach, 
         one_of(names(coef(mod.avg))[-1]),
         NetError_rate) %>%
  gather(variable, value, one_of(names(coef(mod.avg))[-1]), NetError_rate) %>%
  left_join(tibble(variable = names(coef(mod.avg)),
                   coef = coef(mod.avg)) %>%
              bind_rows(tibble(variable = 'NetError_rate',
                               coef = 1))) %>%
  mutate(value = value * coef) %>%
  select(-coef) %>%
  mutate(variable = recode(variable, 
                           'NetError_rate' = 'Net Error',
                           'MeanDischarge' = 'Mean Discharge',
                           'MeanThalwegCV' = 'Mean Thalweg CV',
                           'MeanWidth_m' = 'Mean Width (m)',
                           'NaiveDensity_km' = 'Obs Redd Density',
                           'ExpSpTotal' = 'Log Surveyor Exp.')) %>%
  mutate(variable = factor(variable,
                           levels = c('Mean Thalweg CV',
                                      'Obs Redd Density',
                                      'Log Surveyor Exp.',
                                      'Mean Discharge',
                                      'Mean Width (m)',
                                      'Net Error'))) %>%
  ggplot(aes(x = Source, 
             y = value)) +
  # geom_boxplot(aes(fill = Watershed)) +
  geom_boxplot(aes(fill = Source)) +
  scale_fill_brewer(palette = 'Set1') +
  facet_wrap(~ variable, 
             scales = 'free') +
  theme(legend.position = 'bottom') +
  geom_hline(yintercept = 0,
             linetype = 2) +
  labs(title = 'Covariates x Coefficients')


ne.covars.p3 = sthd_redd_df %>%
  select(River:Reach,
         Index,
         Survey.Date,
         one_of(names(coef(mod.avg))[-1])) %>%
  gather(variable, value, one_of(names(coef(mod.avg))[-1])) %>%
  left_join(covar_center %>%
              rename(variable = metric)) %>%
  mutate(value = value / sd) %>%
  select(-mean, -sd) %>% 
  left_join(tibble(variable = names(coef(mod.avg)),
                   coef = coef(mod.avg)) %>%
              mutate(sign = ifelse(coef < 0, '(-)', '(+)')) %>%
              select(-coef)) %>%
  mutate(prnt_var = paste(variable, sign)) %>%
  ggplot() +
  geom_histogram(aes(x = value,
                     y = ..density..,
                     fill = '2018'),
                 binwidth = 0.2) +
  geom_vline(xintercept = 0,
             linetype = 2,
             color = 'black') +
  stat_function(fun = dnorm,
                aes(color = 'Model'),
                lwd = 1.5) +
  scale_color_manual(values = c('Model' = 'red'),
                     name = 'Data Source') +
  scale_fill_manual(values = c('2018' = 'blue'),
                     name = 'Data Source') +
  theme(legend.position = 'bottom') +
  facet_wrap(~ prnt_var) +
  labs(title = 'Distribution of Covariates',
       x = 'z-value')
         

# save covariate plots
list(ne.covars.p,
     ne.covars.p2,
     ne.covars.p3) %>%
  marrangeGrob(grobs = ., 
                 nrow=1, 
                 ncol=1,
                 top = NULL) %>%
    ggsave(filename = 'Outgoing/NetErrorCovariates.pdf',
           plot = .,
           width = 7,
           height = 10,
           units = 'in')

```


```{r estimate_redds}
# minimum number of total redds observed
min.num.redds = 2
# minimum number of weeks with at least one new redd observed
min.num.non0.wks = 3

res_list = sthd_redd_df %>%
  filter(Survey.Type == 'Weekly',
         Index == 'Y') %>%
  split(list(.$River, .$Reach))
res_list = res_list[which(sapply(res_list, nrow) > 0)]

redd.results = res_list %>%
  map(.f = function(x) {
    res = x %>%
      group_by(River, Reach, Index, Survey.Type) %>%
      summarise(n.weeks = n(),
                n.non0.wks = sum(New.Redds > 0, na.rm=T),
                surv_int = mean(as.numeric(diff(Survey.Date))),
                surv_int_sd = sd(as.numeric(diff(Survey.Date))),
                Sum.Total.Features = sum(New.Redds, na.rm=T),
                Redds.Est = NA,
                Redds.SE = NA,
                Err.Est = mean(Net.Error), 
                Err.SE = mean(Net.Error.SE),
                a = NA, ms = NA, tau2 = NA, gauc = 0) %>%
      ungroup() %>%
      mutate(Err.SE = ifelse(is.na(Err.Est), 0, Err.SE),
             Err.Est = ifelse(is.na(Err.Est), 1, Err.Est))
    
    g.fit = try(x %>%
                  select(Day = survey,
                         Redds = New.Redds) %>%
                  GAUCfnc(., 
                          SL = 1,
                          SL.se = 0,
                          v = res$Err.Est,
                          v.se = res$Err.SE))
    if(class(g.fit) == 'list') {
      res %<>%
        mutate(Redds.Est = round(g.fit$E),
               Redds.SE = g.fit$E.se,
               a = g.fit$Ncurve['a'],
               ms = g.fit$Ncurve['ms'],
               tau2 = g.fit$Ncurve['tau2'],
               gauc = T)
    }
    # if GAUC model doesn't fit, take observed redds, divide by net error
    if(is.na(g.fit$E) | 
       !g.fit$model$converged | 
       res$Sum.Total.Features < min.num.redds | 
       res$n.non0.wks < min.num.non0.wks) {
      res %<>%
        mutate(Redds.Est = round(Sum.Total.Features / Err.Est),
               Redds.SE = deltamethod(~ x1 / x2, 
                                      mean = c(Sum.Total.Features, Err.Est), 
                                      cov = diag(c(0, Err.SE^2))),
               gauc = F)
    }
    
    return(res)

    
  }) %>%
  map_df(.id = NULL,
         .f = identity)

# add non-index reaches to results
redd.results %<>%
  bind_rows(sthd_redd_df %>%
              anti_join(redd.results) %>%
              group_by(River, Reach, Index, Survey.Type) %>%
              summarise(n.weeks = n_distinct(Survey.Date),
                        n.non0.wks = sum(New.Redds > 0, na.rm=T),
                        n.non0.wks = ifelse(is.na(n.non0.wks), 0, n.non0.wks),
                        surv_int = ifelse(n.weeks > 1, mean(as.numeric(diff(Survey.Date))), NA),
                        surv_int_sd = ifelse(n.weeks > 1, sd(as.numeric(diff(Survey.Date))), NA),
                        Sum.Total.Features = sum(New.Redds, na.rm=T),
                        Err.Est = mean(Net.Error),
                        Err.SE = mean(Net.Error.SE),
                        Redds.Est = Sum.Total.Features / Err.Est,
                        Redds.SE = Sum.Total.Features * Err.SE / (Err.Est^2),
                        Redds.CV = Redds.SE / Redds.Est,
                        gauc = F) %>%
              ungroup()) %>%
  arrange(River, Reach)
```

```{r gauc_plots}
p = sthd_redd_df %>%
  select(-one_of(names(coef(mod.avg))[-1])) %>%
  left_join(sthd_redd_org) %>%
  select(River:Survey.Type, survey, New.Redds, Visible.Redds) %>%
  left_join(redd.results) %>%
  filter(Redds.Est > 0) %>%
  filter(gauc) %>%
  ggplot(aes(x = survey, 
             y = New.Redds,
             group = Reach)) +
  geom_point() +
  facet_wrap(~ Reach, 
             scales='free',
             ncol = 2) +
  stat_smooth(method = 'glm', 
              formula = y ~ x + I(x^2), 
              method.args = list(family = quasipoisson), 
              fullrange = T, 
              se = T) + 
  # geom_text(data = redd.results %>%
  #             filter(gauc),
  #           aes(x = -Inf, 
  #               y = Inf, 
  #               group = Reach,
  #               label = paste0('Obs Redds = ', Sum.Total.Features, '\n',
  #                              'Net Error = ', round(Err.Est, 2), '\n',
  #                              'Est Redds = ', round(Redds.Est), '\n',
  #                              'Est CV = ', round(Redds.SE / Redds.Est, 2))),
  #           vjust=1.2, 
  #           hjust=-0.2, 
  #           size=3) +
  labs(x = 'Survey Number', 
       y = 'New Redds', 
       title='GAUC Reaches') +
  theme(strip.text = element_text(size=12))

ggsave('Outgoing/Wen_IndexReaches.pdf', 
       p, 
       width = 8, 
       height = 8)


# create summary table of results
summ_tab = redd.results %>%
  mutate(Net.Error.CV = Err.SE / Err.Est) %>%
  # mutate(Redd.Life.CV = RL.se / RL.Mean) %>%
  select(Reach,
         Survey.Type,
         Redds.Counted = Sum.Total.Features,
         Net.Error = Err.Est,
         Net.Error.SE = Err.SE,
         Net.Error.CV,
         Redds.Est:Redds.SE) %>%
  mutate(Redds.Est = ifelse(Redds.Counted > 0 & round(Redds.Est) == 0, ceiling(Redds.Est), round(Redds.Est))) %>%
  mutate(Redds.CV = Redds.SE / Redds.Est) %>%
  arrange(Reach)

# save results as csv
summ_tab %>%
  write_csv(path = 'Outgoing/SthdReddsEst_Index_2018.csv')

```

```{r total_redds}
# put together estimates of redds in all reaches
results_tab = summ_tab %>%
  select(Reach:Redds.Counted, Redds.Est:Redds.CV) %>%
  rename(Type = Survey.Type) %>%
  mutate(Type = recode(Type,
                       'Weekly' = 'Index',
                       'Peak' = 'Non-Index')) %>%
  select(Reach, Type, everything()) %>%
  arrange(Reach, Type) %>%
    mutate(Redds.Est = ifelse(Redds.Counted == 0, 0, Redds.Est),
         Redds.SE = ifelse(Redds.Counted == 0, 0, Redds.SE),
         Redds.CV = ifelse(Redds.Counted == 0, NA, Redds.CV))

#-------------------------------------
# look at correlations between reaches
#-------------------------------------
rch_nms = filter(results_tab, 
                 Reach != 'Total', 
                 Redds.Counted > 0,
                 grepl('^W', Reach)) %>%
           select(Reach) %>%
           distinct() %>%
           as.matrix() %>%
           as.character()
rch_cor = sthd_redd_df %>%
  mutate(week = week(Survey.Date),
         week = week - min(week) + 1) %>%
  filter(Reach %in% rch_nms) %>%
  select(Reach:Survey.Type, week, New.Redds) %>%
  group_by(Reach, Index, Survey.Type, week) %>%
  summarise_at(vars(New.Redds),
               funs(sum)) %>%
  ungroup() %>%
  spread(week, New.Redds) %>%
  filter(Index == 'Y') %>%
  select(-(Reach:Survey.Type)) %>%
  t() %>%
  cor(use = 'pairwise.complete.obs')
dimnames(rch_cor) = list(rch_nms, rch_nms)

# get total estimate of redds in Wenatchee, using covariance
redds_index = results_tab %>%
  filter(Type == 'Index') %>%
  summarise(Redds.Counted = sum(Redds.Counted),
            Redds.Est = sum(Redds.Est),
            Redds.SE = NA)

redd_mean = results_tab %>%
  filter(Reach %in% rch_nms,
         Type == 'Index') %>%
  select(Redds.Est) %>%
  as.matrix() %>% as.numeric()
redd_stddev = results_tab %>%
  filter(Reach %in% rch_nms, 
         Type == 'Index') %>%
  select(Redds.SE) %>%
  as.matrix() %>% as.numeric()
redd_cov = diag(redd_stddev^2)
for(i in 1:nrow(redd_cov)) {
  for(j in 2:nrow(redd_cov)) {
    if(i==j) next
    redd_cov[i,j] = redd_cov[j,i] = rch_cor[i,j] * prod(redd_stddev[c(i,j)])
  }
}
redds_index$Redds.SE = deltamethod(as.formula(paste('~', paste(paste0('x', 1:length(redd_mean)), collapse = '+'))), mean = redd_mean, cov = redd_cov)

redds_tot = results_tab %>%
  filter(Type == 'Non-Index',
         grepl('^W', Reach)) %>%
  summarise(Redds.Counted = sum(Redds.Counted),
            Redds.Est = sum(Redds.Est),
            Redds.SE = sqrt(sum(Redds.SE, na.rm=T)^2)) %>%
  ungroup() %>%
  bind_rows(redds_index) %>%
  summarise(Reach = 'Total',
            Redds.Counted = sum(Redds.Counted),
            Redds.Est = sum(Redds.Est),
            Redds.SE = sqrt(sum(Redds.SE, na.rm=T)^2),
            Redds.CV = Redds.SE / Redds.Est)

results_tab %<>%
  bind_rows(redds_tot)

```

```{r redds_to_spawners}
# how many hatchery fish were removed at Tumwater?
# based on email from Mclain
hatch_rm_tum = 62 + 0 # broodstock + surplussed
wild_rm_tum = 66
hatch_rm_dryden = 27
wild_rm_dryden = 14
hatch_harvest = 0
wild_harvest = 0


# # assume no removals
# hatch_rm_tum = 0
# wild_rm_tum = 0
# hatch_rm_dryden = 0
# hatch_harvest = 0
# wild_harvest = 0

load('/Users/kevin/Dropbox/ISEMP/Analysis_Projects/UpperColumbia_AdultEscapement/UC_Steelhead/2011_2017_DABOM/modelFits/PRA_Steelhead_2018_DABOM.rda')
# fix a few prefixes for tags with known issues (Ben Truscott had to enter them incorrectly in his database)
bio_df %<>%
  mutate(TagID = ifelse(!TagID %in% dabom_df$TagID,
                        str_replace(TagID, 
                                    '^3DD', 
                                    '3DA'),
                        TagID))

tag_summ = summariseTagData(proc_list$ProcCapHist %>%
                              mutate(lastObsDate = ObsDate) %>%
                              left_join(proc_list$NodeOrder %>%
                                          mutate(Group = fct_expand(Group, 'WellsPool'),
                                                 Group = if_else(Node == 'WEA',
                                                                 'WellsPool',
                                                                 as.character(Group)),
                                                 Group = ifelse(NodeSite %in% c('FST', 'RRF', 'WVT', 'RIA', 'CLK'),
                                                                NA,
                                                                Group),
                                                 Group = factor(Group,
                                                                levels = c('Wenatchee', 'Entiat', 'Methow', 'Okanogan', 'WellsPool', 'BelowPriest')))) %>%
                              mutate(SiteID = NodeSite),
                            trap_data = bio_df %>%
                              mutate(Age = str_replace(Age, 'r', 'R'))) %>%
  rename(Branch = Group)

wen_tags = tag_summ %>%
  filter(grepl('LWE', TagPath)) %>%
  mutate(Area = ifelse(AssignSpawnNode == 'TUM',
                       'TUM_bb',
                       ifelse(grepl('TUM', TagPath),
                              'Tribs_above_TUM',
                              'Below_TUM'))) %>%
  mutate(Area = factor(Area,
                       levels = c("Below_TUM", 'TUM_bb', 'Tribs_above_TUM'))) %>%
  select(TagID, Location = Area, Origin, Sex)
  
#-------------------------------------------------------
# if differentiating between above and below Tumwater
wen_prop_sex = wen_tags %>%
  group_by(Location, Sex) %>%
  summarise(n_tags = n()) %>%
  ungroup() %>%
  left_join(group_by(., Location) %>%
              summarise(tot_tags = sum(n_tags))) %>%
  mutate(prop = n_tags / tot_tags,
         prop_se = sqrt((prop * (1 - prop)) / tot_tags))

wen_sex_tab = wen_prop_sex %>%
  select(Location, Sex, tot_tags, n_tags) %>%
  spread(Sex, n_tags) %>%
  rename(f_tags = F,
         m_tags = M) %>%
  left_join(wen_prop_sex %>%
              select(Location, Sex, tot_tags, prop) %>%
              spread(Sex, prop) %>%
              rename(f_prop = F,
                     m_prop = M)) %>%
  rowwise() %>%
  mutate(prop_se = sqrt((f_prop * m_prop) / tot_tags),
         # calculate fish / redd as F:M + 1
         fpr = (m_prop / f_prop) + 1,
         fpr_se = deltamethod(~ (x1 / x2) + 1, 
                              mean = c(m_prop, f_prop), 
                              cov = diag(prop_se^2, nrow = 2)))

wen_prop_origin = wen_tags %>%
  group_by(Location, Origin) %>%
  summarise(n_tags = n()) %>%
  ungroup() %>%
  left_join(group_by(., Location) %>%
              summarise(tot_tags = sum(n_tags))) %>%
  mutate(prop = n_tags / tot_tags,
         prop_se = sqrt((prop * (1 - prop)) / tot_tags))

wen_origin_tab = wen_prop_origin %>%
  select(Location, Origin, tot_tags, n_tags) %>%
  spread(Origin, n_tags) %>%
  rename(h_tags = H,
         w_tags = W) %>%
  left_join(wen_prop_origin %>%
              select(Location, Origin, tot_tags, prop) %>%
              spread(Origin, prop) %>%
              rename(h_prop = H,
                     w_prop = W)) %>%
  mutate(prop_se = sqrt((h_prop * w_prop) / tot_tags))


mainstem_spawners = results_tab %>%
  filter(Reach != 'Total') %>%
  filter(grepl('^W', Reach)) %>%
  mutate(Location = ifelse(Reach %in% paste0('W', 1:7), 'Below_TUM', 'TUM_bb')) %>%
  left_join(wen_sex_tab %>%
              select(Location, fpr, fpr_se)) %>%
  left_join(wen_origin_tab %>%
              select(Location, h_prop:prop_se)) %>%
  rowwise() %>%
  mutate(Tot_Spawners = Redds.Est * fpr,
         Hatchery = Redds.Est * fpr * h_prop,
         Natural = Redds.Est * fpr * w_prop,
         Hatchery_SE = ifelse(Tot_Spawners > 0, 
                              deltamethod(~ x1 * x2 * x3,
                                          mean = c(Redds.Est, fpr, h_prop),
                                          cov = diag(c(Redds.SE, fpr_se, prop_se)^2)),
                              NA),
         Natural_SE = ifelse(Tot_Spawners > 0, 
                              deltamethod(~ x1 * x2 * x3,
                                          mean = c(Redds.Est, fpr, w_prop),
                                          cov = diag(c(Redds.SE, fpr_se, prop_se)^2)),
                              NA))

mainstem_spawners %<>%
  select(Reach, Type, Hatchery, Natural) %>%
  gather(Origin, Spawners, -(Reach:Type)) %>%
  left_join(mainstem_spawners %>%
              select(Reach, Type, Hatchery_SE, Natural_SE) %>%
              gather(Origin, Spawners_SE, -(Reach:Type)) %>%
              mutate(Origin = recode(Origin, 
                                     'Hatchery_SE' = 'Hatchery', 
                                     'Natural_SE' = 'Natural'))) %>%
  mutate(Reach = factor(Reach, levels = levels(sthd_redd_df$Reach))) %>%
  arrange(Reach, Type, Origin)


# pull in estimates of escapement
all_summ = read_excel('/Users/kevin/Dropbox/ISEMP/Analysis_Projects/UpperColumbia_AdultEscapement/UC_Steelhead/2011_2017_DABOM/outgoing/PRA_Steelhead_2018_20181219.xlsx',
                      'All Escapement')

trib_spawners = all_summ %>%
  filter(param %in% c('past_ICL',
                      'past_PES',
                      'past_MCL',
                      'past_CHM',
                      'past_CHW',
                      'past_CHL',
                      'past_NAL',
                      'past_LWN',
                      'past_WTL')) %>%
  select(Origin, Location = param, Spawners = median, Spawners_SE = sd) %>%
  arrange(Location, Origin)

spawner_est = mainstem_spawners %>%
  rename(Area = Reach) %>%
  bind_rows(trib_spawners %>%
              mutate(Type = 'Trib') %>%
              rename(Area = Location)) %>%
  mutate(Spawners_CV = Spawners_SE / Spawners,
         Spawners = round(Spawners))


# get total spawners in the Wenatchee
mainstem_index = mainstem_spawners %>%
  filter(Type == 'Index') %>%
  group_by(Origin) %>%
  summarise(Spawners = sum(Spawners),
            # SE_naive = sqrt(sum(Spawners_SE^2, na.rm=T)),
            SE = NA) %>%
  ungroup() %>%
  select(-SE)

spwn_cov_list = as.list(unique(mainstem_index$Origin))
names(spwn_cov_list) = unique(mainstem_index$Origin)
spwn_cov_list %<>%
  map(.f = function(x) {
    my_origin = x[1]
    spwn_mean = mainstem_spawners %>%
      filter(Type == 'Index',
             Origin == my_origin,
             Reach %in% rownames(rch_cor)) %>%
      select(Spawners) %>%
      as.matrix() %>% as.numeric()
    spwn_stddev = mainstem_spawners %>%
      filter(Type == 'Index',
             Origin == my_origin,
             Reach %in% rownames(rch_cor)) %>%
      select(Spawners_SE) %>%
      as.matrix() %>% as.numeric()
    spwn_cov = diag(spwn_stddev^2)
    for(i in 1:nrow(spwn_cov)) {
      for(j in 2:nrow(spwn_cov)) {
        if(i==j) next
        spwn_cov[i,j] = spwn_cov[j,i] = rch_cor[i,j] * prod(spwn_stddev[c(i,j)])
      }
    }
    return(list('mean' = spwn_mean,
                'vcov' = spwn_cov))
  })

mainstem_se = spwn_cov_list %>%
  map_df(.f = function(x) {
           deltamethod(as.formula(paste('~', paste(paste0('x', 1:length(x$mean)), collapse = '+'))),
                       mean = x$mean, 
                       cov = x$vcov)
         }) %>%
  gather(Origin, SE)

mainstem_index %<>%
  left_join(mainstem_se)

mainstem_tot = spawner_est %>%
  filter(Type == 'Non-Index') %>%
  group_by(Origin) %>%
  summarise(Spawners = sum(Spawners),
            SE = sqrt(sum(Spawners_SE, na.rm=T)^2)) %>%
  ungroup() %>%
  bind_rows(mainstem_index) %>%
  group_by(Origin) %>%
  summarise(Spawners = round(sum(Spawners)),
            Spawners_SE = sqrt(sum(SE, na.rm=T)^2))

# compare with all black boxes in the Wenatachee (mainstem areas)
escape_bb = all_summ %>%
  filter(param %in% c('LWE_bb', 'TUM_bb', 'UWE_bb')) %>%
  group_by(Origin) %>%
  summarise(Escapement = sum(median),
            Escape_SE = sqrt(sum(sd^2)))

# # calculate estimate of prespawn mortality
# mainstem_tot %>%
#   left_join(escape_bb) %>%
#   rename(Init_Escape = Escapement) %>%
#   mutate(Escapement = ifelse(Origin == 'Hatchery',
#                              Init_Escape - (hatch_rm_tum + hatch_rm_dryden + hatch_harvest),
#                              Init_Escape - (wild_rm_tum + wild_rm_dryden + wild_harvest))) %>%
#   mutate(Prespawn_Mort = (Escapement - Spawners) / Escapement)
# 
# get total spawners in the Wenatchee
spawner_tot = spawner_est %>%
  filter(Type != 'Index') %>%
  group_by(Origin) %>%
  summarise(Spawners = sum(Spawners),
            SE = sqrt(sum(Spawners_SE, na.rm=T)^2)) %>%
  ungroup() %>%
  bind_rows(mainstem_index) %>%
  group_by(Origin) %>%
  summarise(Spawners = round(sum(Spawners)),
            SE = sqrt(sum(SE, na.rm=T)^2))

# all_summ %>%
#   filter(Area == 'Wenatchee') %>%
#   select(Origin, Estimate) 
```

```{r list_table_figures}
ne_redds_tab = tab_nums(name = 'ne_redds_tab', 
                          caption = 'Estimates of mean net error and total redds for each reach.')

gauc_fig = fig_nums(name = 'gauc_plots',
                    caption = "Plots of observed redd counts (black dots) through time for each index reach, and the fitted curve from the GAUC model (blue line) with associated uncertainty (gray).")


fpr_hatch_prop_tab = tab_nums(name = 'fpr_hatch_prop_tab',
                                caption = 'Fish per redd and hatchery / natural origin proportion estimates.')

spawn_reach_origin_tab = tab_nums(name = 'spawn_reach_origin_tab',
                                    caption = 'Estimates (CV) of spawners by area and origin.')

prespawn_mort_tab = tab_nums(name = 'prespawn_mort_tab',
                               caption = 'Wenatchee pre-spawn mortality estimates. Includes estimates (standard error) of escapement, spawners, pre-spawn mortality, and CV of this rate, separated by origin.')

prespawn_mort_tab2 = tab_nums('prespawn_mort_tab2', 
                                caption = 'Wenatchee pre-spawn mortality estimates. Includes estimates (standard error) of escapement, spawners, pre-spawn mortality, and the standard error of this rate, separated by origin and mainstem areas above and below Tumwater dam.')

net_error_covariates_fig = fig_nums(name = 'net_error_covariates_fig',
                                    caption = 'Net error covariate values from the study in the Methow and the predicted reaches in the Wenatchee.')

```


\newpage

# Introduction

Redd counts are an established method to provide an index of adult spawners [@Gallagher2007]. In the Wenatchee and Methow subbasins, index reaches are surveyed weekly during the steelhead spawning season (`r format(min(sthd_redd_df$Survey.Date), '%b %d, %Y')` - `r format(max(sthd_redd_df$Survey.Date), '%b %d, %Y')`) and non-index reaches are surveyed once during the peak spawning period. The goal of this work is to:

* Predict observer net error, using the model described in @Murdoch2018.
* Use estimates of observer net error rates and the mean survey interval to estimate the number of redds in each index reach, using a Gaussian area under the curve (GAUC) technique described in @Millar2012.
* Estimate the total number of redds in the non-index reaches by adjusting the observed counts with the estimated net error.
* Convert these estimates of redds in the mainstem areas (surveyed for redds) into estimates of spawners.
* Use PIT-tag based estimates of escapement for all tributaries in the Wenatchee, and combine those estimates with the redd-based estimates of spawners in the mainstem areas to estimate the total number of spawners in the Wenatchee.

# Methods

## Mainstem areas

The model for observer net error (observed redd counts / true number of redds) is fully described in @Murdoch2018. It involves model averaging of the `r nrow(mod.avg$msTable)` best models that were fit to `r nrow(mod.avg$x)` data points collected in the Methow. Both models contained covariates for the observed redd density and mean thalweg CV as a proxy for channel complexity, while `r summary(mod.avg)$coef.nmod[1,'MeanDischarge'] %>% as.english()` each contained the log of total redd survey experience and discharge. Predictions were made using model averaged coefficients (based on AICc model weights) and the 2018 steelhead data. From these survey specific estimates of net error, a mean and standard error of net error was calculated for each reach. The standard deviation was calculated by taking the square root of the sum of the squared standard errors for all predictions within a reach.

Estimates of total redds were made for each index reach with a minimum of `r as.english(min.num.redds)` and at least `r as.english(min.num.non0.wks)` using the GAUC model described in @Millar2012 and @Murdoch2018. The GAUC model was developed with spawner counts in mind. As it is usually infeasible to mark every individual spawner, only total spawner counts can be used, and an estimate of average stream life must be utilized to translate total spawner days to total unique spawners. However, in adapting this for redd surveys, two modification could be used. The first would fit GAUC models to data showing all visible redds at each survey, and use an estimate of redd life as the equivalent of spawner stream life. However, because conditions can lead to many redds not disappearing before the end of the survey season, the estimates of redd life can be biased low. The second method relies on the fact that individual redds can be marked, and therefore the GAUC model can be fit to new redds only. The equivalent of stream life thus the difference between survey numbers which can be fixed at 1. We utilized the second method for this analysis.

For non-index reaches, which were surveyed only once during peak spawning, the estimate of total redds was calculated by dividing the observed redds by the estimate of net error associated with that survey. This assumes that no redds were washed out before the non-index survey, and that no new redds appeared after that survey. As the number of redds observed in the non-index reaches ranged from `r paste(range(sthd_redd_df$New.Redds[sthd_redd_df$Index == 'N']), collapse = ' to ')`, any violoation of this assumption should not affect the overall estimates very much. Any index reaches that did not meet the thresholds described above were treated as non-index reaches, and the total observed redds in those reaches were divided by an estimate of net error for each reach.

To convert estimates of total redds into estimates of natural and hatchery spawners, total redds were multiplied by a fish per redd (FpR) estimate and then by the proportion of hatchery or wild fish. The fish per redd estimate was based on PIT tags from the branching patch-occupany model (see below) observed to move into the lower or upper Wenatchee (below or above Tumwater dam). FpR was calculated as the ratio of male to female fish, plus 1. This was `r round(wen_sex_tab$fpr[1], 2)` above Tumwater dam, and `r round(wen_sex_tab$fpr[2], 2)` below Tumwater. Reaches W1 - W7 are below Tumwater, while reaches W8 - W10 are above Tumwater. Similarly, the proportion of hatchery and natural origin fish was calculated from the same group of PIT tags for areas above and below Tumwater. The proportion of hatchery origin fish was `r round(wen_origin_tab$h_prop[1], 2)` above Tumwater dam, and `r round(wen_origin_tab$h_prop[2], 2)` below Tumwater (`r tab_nums('fpr_hatch_prop_tab', display = "cite")`). 

## Tributary areas

Esimates of escapement to various tributaries in the Wenatchee were made using a branching patch-occupancy model (Waterhouse, L. et al., *in prep*) based on PIT tag observations of fish tagged at Priest Rapids dam. All fish that escaped to the various tributaries were assumed to be spawners (i.e. pre-spawn mortality only occurs in the mainstem).

## Total spawners

When summing spawner estimates from index reaches to obtain estimates of total spawners in the Wenatchee, an attempt was made to incorporate the fact that the reaches within a stream are not independent. Estimates of correlation between the reaches within a stream were made based on weekly observed redds. Because correlations are often quite high between reaches, this is a better alternative than to naively assume the standard errors between reaches are independent of one another. These estimates of correlation were combined with estimates of standard error for each index reach to calculate a covariance matrix for the Wenatchee index reaches where redds were found (`r paste(rownames(rch_cor), collapse = ', ')`), which was used when summing estimates of spawners to estimate the total standard error. Failure to incorporate the correlations between reaches would result in an underestimate of standard error at the population scale. Non-index reaches were only surveyed once, so it is impossible to estimate a correlation coefficient between non-index reaches and index reaches. Therefore, they were assumed to be independent from the index reachs when summing the estimates of spawners. Because the estimates of tributary spawners were made separately (see above), they were also treated as independent when summing spawner estimates. The uncertainty in each step was carried through the entire analysis via the delta method [@Casella2002].

## Prespawn Mortality

After translating estimates of redds to estimates of spawners by origin, we can then compare the spawner estimates to escapement estimates made using PIT tags, and estimate a prespawn mortality rate (`r tab_nums('prespawn_mort_tab', display = 'cite')`). Taking the total PIT-tag based escapement estimate to the Wenatchee (after subtracting the `r hatch_rm_tum` hatchery and `r wild_rm_tum` wild fish removed at Tumwater, as well as the `r hatch_rm_dryden` hatchery fish and `r wild_rm_dryden` wild fish removed at Dryden, and the `r hatch_harvest` and `r wild_harvest` deaths to hatchery and wild fish due to harvest), and subtracting the total estimate of spawners, including the tributaries, then dividing by the total escapement estimate provides an estimate of pre-spawn mortality across the entire Wenatchee population. We can also compare estimates of escapement from the "black box" above LWE (after subtracting `r hatch_rm_dryden` hatchery and `r wild_rm_dryden` wild fish removed at Dryden) and the "black box" above Tumwater (after subtracting the `r hatch_rm_tum` hatchery and `r wild_rm_tum` wild fish removed at Tumwater) to total estimates of spawners in mainstem areas below and above Tumwater dam. This allows us to estimate pre-spawn mortality in the mainstem above and below Tumwater, by origin. 

\newpage

# Results

## Redd estimates

The estimated net error, observed redds and estimates of redds are shown in `r tab_nums('ne_redds_tab', display = 'c')`. 

`r tab_nums('ne_redds_tab', display = "full")`
```{r net_error_redd_life_table}
summ_tab %>%
  rename(Type = Survey.Type) %>%
  mutate(Type = recode(Type,
                       'Weekly' = 'Index',
                       'Peak' = 'Non-Index')) %>%
  # mutate(Type = 'Index',
  #        Index.Reach = '-') %>%
  select(Reach, Type, Net.Error:Net.Error.CV) %>%
  # bind_rows(non.index.data %>%
  #             mutate(Type = 'Non-Index',
  #                    Net.Error.CV = Net.Error.SE / Net.Error) %>%
  #             select(Reach, Type, Index.Reach, matches('Net.Error')) %>%
  #             distinct()) %>%
  select(-matches('SE')) %>%
  arrange(Reach, Type) %>%
  full_join(results_tab %>%
              select(-Redds.SE) %>%
              distinct()) %>%
  pander(digits = c(0, 0, 2, 2, 0, 0, 2),
         emphasize.strong.rows = nrow(.))
```

\newpage

```{r GAUC_plots, fig.cap = fig_nums('gauc_plots')}
print(p)
```

\newpage

## Spawner estimates

Parameter estimates for fish / redd and proportion hatchery based on PIT tag data are shown in `r tab_nums('fpr_hatch_prop_tab', display = "c")`.

`r tab_nums('fpr_hatch_prop_tab', display = "full")`
```{r fpr_hatch_prop_tab}
wen_sex_tab %>%
  select(Location, fpr, fpr_se) %>%
  left_join(wen_origin_tab %>%
              select(Location, h_prop, prop_se)) %>%
  mutate(Location = recode(Location, 
                           'Tribs_above_TUM' = 'Tribs above TUM', 
                           'Below_TUM' = 'Below TUM',
                           'TUM_bb' = 'Mainstem above TUM')) %>%
  pander(digits = c(0, rep(3, 4)),
         col.names = c('Area', 'Fish / redd', 'FpR Std. Error', 'Prop. Hatchery', 'Prop Std. Error'))
```

Combining PIT tag-based estimates of spawners in the tributaries with adjusted redd-based estimates of spawners in the mainstem areas, `r tab_nums('spawn_reach_origin_tab', display = "c")` shows all of them, broken down by area and origin.

\newpage

`r tab_nums('spawn_reach_origin_tab', display = "full")`
```{r spawn_reach_origin_tab}
spawner_est %>%
  rename(CV = Spawners_CV) %>%
  mutate(Spawners = paste0(Spawners, ' (', round(CV, 2), ')'),
         Spawners = gsub('NA', '--', Spawners),
         Spawners = gsub('NaN', '--', Spawners)) %>%
  select(-(Spawners_SE:CV)) %>%
  distinct() %>%
  spread(Origin, Spawners) %>%
mutate(Area = recode_factor(Area,
                              'past_CHL' = 'Chiwawa',
                              'past_CHM' = 'Chumstick',
                              'past_CHW' = 'Chiwaukum',
                              'past_ICL' = 'Icicle',
                              'past_LWN' = 'Little Wenatchee',
                              'past_MCL' = 'Mission',
                              'past_NAL' = 'Nason',
                              'past_PES' = 'Peshastin',
                              'past_WTL' = 'White River'),
         Area = factor(Area, levels = c(paste0('W', 1:10), 'Icicle', 'Peshastin', 'Mission', 'Chumstick', 'Chiwaukum', 'Chiwawa', 'Nason', 'Little Wenatchee', 'White River'))) %>%
  arrange(Area) %>%
  bind_rows(spawner_tot %>%
              mutate(CV = SE / Spawners,
                     Spawners = paste0(Spawners, ' (', round(CV, 2), ')')) %>%
              select(-(SE:CV)) %>%
              mutate(Area = 'Total',
                     Type = '') %>%
              spread(Origin, Spawners)) %>%
  pander(emphasize.strong.rows = nrow(.))
```

## Prespawn Mortality

The estimates of overall prespawn mortality within the Wenatchee population are shown in `r tab_nums('prespawn_mort_tab', display = 'c')`. 

`r tab_nums('prespawn_mort_tab', display = 'full')`
```{r prespawn_mort_tab, eval = T}
all_summ %>%
  filter(param == 'past_LWE') %>%
  select(Origin, Init_Escape = median, Escape_SE = sd) %>%
  # account for the fact that many hatchery and some wild fish are removed at Tumwater & Dryden
  mutate(Escapement = ifelse(Origin == 'Hatchery', 
                             Init_Escape - (hatch_rm_tum + hatch_rm_dryden + hatch_harvest),
                             Init_Escape - (wild_rm_tum + wild_rm_dryden + wild_harvest))) %>%
  left_join(spawner_tot) %>%
  rowwise() %>%
  mutate(Prespawn_Mort = (Escapement - Spawners) / Escapement,
         Prespawn_SE = deltamethod(~ (x1 - x2) / x1, 
                                   mean = c(Escapement, Spawners),
                                   cov = diag(c(Escape_SE, SE)^2)) / Escapement,
         Prespawn_CV = Prespawn_SE / Prespawn_Mort) %>%
  mutate(Escp_print = paste0(round(Escapement), ' (', round(Escape_SE), ')'),
         Spwn_print = paste0(round(Spawners), ' (', round(SE), ')')) %>%
  select(Origin, #Init_Escape, 
         Escapement = Escp_print,
         Spawners = Spwn_print,
         `Prespawn Mortality` = Prespawn_Mort, 
         CV = Prespawn_CV) %>%
  pander(digits = c(0, 0, 0, 2, 4))

```

However, when focused on the mainstem areas above and below Tumwater, there was evidence for substantial prespawn mortality. For natural origin fish below Tumwater, we found that the estimates of escapement were smaller than the estimates of spawners, leading to negative estimates of pre-spawn mortality, but the escapement and spawner estimates had overlapping confidence intervals, so not too much should be made about higher spawner estimates compared to escapement. For the other groups, it appears prespawn mortality was quite high (`r tab_nums('prespawn_mort_tab2', display = 'c')`). 

\newpage

`r tab_nums('prespawn_mort_tab2', display = 'full')`
```{r prespawn_mort_tab_tum_split}
all_summ %>%
  mutate(Loc = ifelse(param %in% c('TUM_bb', 'UWE_bb'), 'AboveTUM_bb', NA),
         Loc = ifelse(param == 'LWE_bb', 'LowWen_bb', Loc)) %>%
  filter(!is.na(Loc)) %>%
  group_by(Loc, Origin) %>%
  summarise(Estimate = sum(median),
            SE = sqrt(sum(sd^2))) %>%
  ungroup() %>%
  select(Origin, Loc, Init_Escape = Estimate, Escape_SE = SE) %>%
  # account for the fact that many hatchery and some wild fish are removed at Tumwater
  mutate(Escapement = ifelse(Origin == 'Hatchery' & Loc == 'AboveTUM_bb', 
                             Init_Escape - (hatch_rm_tum), 
                             Init_Escape),
         Escapement = ifelse(Origin == 'Natural' & Loc == 'AboveTUM_bb', 
                             Init_Escape - (wild_rm_tum), 
                             Init_Escape),
         Escapement = ifelse(Origin == 'Hatchery' & Loc == 'LowWen_bb', 
                             Init_Escape - (hatch_rm_dryden), 
                             Init_Escape),
         Escapement = ifelse(Origin == 'Natural' & Loc == 'LowWen_bb', 
                             Init_Escape - (wild_rm_dryden), 
                             Init_Escape)) %>%
  left_join(spawner_est %>%
              filter(Spawners > 0) %>%
              mutate(Loc = ifelse(Area %in% paste0('W', 8:10), 'AboveTUM_bb',
                                  ifelse(Area %in% paste0('W', 1:7), 'LowWen_bb', NA))) %>%
              # mutate(Loc = ifelse(Area %in% c(paste0('W', 8:10), 'White_River', 'Nason', 'Chiwawa', 'Chiwaukum', 'Little_Wenatchee'), 'TUM_bb', NA),
              #        Loc = ifelse(Area %in% c(paste0('W', 1:7), 'Icicle', 'Mission', 'Peshastin', 'Chumstick'), 'Below_TUM', Loc)) %>%
              filter(!is.na(Loc)) %>%
              group_by(Loc, Origin) %>%
              summarise(Spawners = sum(Spawners),
                        SE = sqrt(sum(Spawners_SE^2))) %>%
              ungroup()) %>%
  rowwise() %>%
  mutate(Prespawn_Mort = (Escapement - Spawners) / Escapement,
         Prespawn_SE = deltamethod(~ (x1 - x2) / x1, 
                                   mean = c(Escapement, Spawners),
                                   cov = diag(c(Escape_SE, SE)^2)) / Escapement,
         Prespawn_CV = abs(Prespawn_SE / Prespawn_Mort)) %>%
  mutate(Escp_print = paste0(round(Escapement), ' (', round(Escape_SE), ')'),
         Spwn_print = paste0(round(Spawners), ' (', round(SE), ')')) %>%
  mutate_at(vars(Prespawn_CV),
            funs(round),
            digits = 3) %>%
  select(Origin, Loc, #Init_Escape, 
         Escapement = Escp_print,
         Spawners = Spwn_print,
         `Prespawn Mortality` = Prespawn_Mort, 
         SE = Prespawn_SE) %>%
         # CV = Prespawn_CV) %>%
  arrange(Loc, desc(Origin)) %>%
  mutate(Loc = recode(Loc,
                      'AboveTUM_bb' = 'Mainstem above Tumwater',
                      'LowWen_bb' = 'Mainstem below Tumwater')) %>%
  pander(digits = c(0, 0, 0, 0, 2, 3),
         split.table = Inf)
```


```{r prespawn_mort_test, eval = F}
# test of difference in pre-spawn mortality between natural and hatchery fish
all_summ %>%
  filter(param == 'past_LWE') %>%
  select(Origin, 
         Escapement = median, 
         Escape_SE = sd) %>%
         # account for the fact that many hatchery fish are removed at Tumwater
  mutate(Escapement = ifelse(Origin == 'Hatchery', 
                             Escapement - (hatch_rm_tum + hatch_rm_dryden + hatch_harvest), 
                             Escapement - (wild_rm_tum + wild_rm_dryden + wild_harvest))) %>%
  left_join(spawner_tot) %>%
  rowwise() %>%
  mutate(Morts = Escapement - Spawners,
         Prespawn_Mort = (Escapement - Spawners) / Escapement,
         Prespawn_SE = deltamethod(~ (x1 - x2) / x1, 
                                   mean = c(Escapement, Spawners),
                                   cov = diag(c(Escape_SE, SE)^2)) / Escapement,
         Prespawn_CV = Prespawn_SE / Prespawn_Mort) %>%
  select(Spawners, Morts) %>%
  mutate(Morts = ifelse(Morts < 0, 0, Morts)) %>%
  as.matrix() %>%
  prop.test()

```

# Discussion

Estimated net error rates in 2018 were similar to those in the net error model dataset. 

The estimates of high prespawn mortality in the lower mainstem of the Wenatchee could be accurate, but it should be noted that many of the redd surveys failed to observe a single redd in many of the reaches (`r tab_nums('ne_redds_tab', display = 'c')`). Without any observed redds, any estimate of net error is moot, as the adjusted redd estimate will still be zero. So if all the redds were missed in some of those reaches, the estimate of total spawners in the lower mainstem should be higher, leading to a lower estimate of prespawn mortality. It is unclear whether that actually occurred, or if there were actually no redds this year in those reaches.

As for any negative estimates of pre-spawn mortality rates, this should be interpretted as evidence for very low levels of pre-spawn mortality. Overlapping confidence intervals between estimated escapement and estimated spawners mean that although we estimated more spawners than esacpement, not too much should be made of that fact.

```{r, net_error_covariates, fig.height = 5.5, fig.cap = fig_nums('net_error_covariates_fig')}
print(ne.covars.p)
```

\newpage

# References
